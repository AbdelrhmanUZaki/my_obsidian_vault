---
share_link: https://share.note.sx/fjvfmr1x#DZNOWkJ8hAmCeOW4pQwF6im+0asRz65E6qpDkCEnlSk
share_updated: 2023-12-03T23:17:53+02:00
dg-publish: true
---
  

## Common defenses:

1. **Referer-based validation**
2. **CSRF tokens**
    - Unique, secret, and unpredictable value generated by the server-side application.
    - Needed when performing sensitive actions.
    - **Bypassing CSRF token validation**
        - **Validation depends on request method**, e.g. changing POST to GET.
        - **Validation depends on token being present**
            - Delete token from CSRF PoC
        - **CSRF token is not tied to user session**
            - Use your own CSRF Token from your account while creating your CSRF PoC
            - If CSRF Token is valid for one-time use:
                - Send request with vulnerable function with your account
                - Pick up your CSRF Token
                - Drop previous request to keep CSRF token valid, continue with remaining steps
        - **CSRF token is tied to non-session cookie**
            - Use your CSRF Token with one of session cookies
            - Replace victim's "csrfkey" cookie and CSRF Token with yours
            - Find a function without CSRF protection.
            - Inject "csrfkey" cookie using http header injection in CSRF PoC
            - Ex: `/?Search_Function_Without_Protection=something_to_search_about%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY`
            - Now able to send your "csrfkey" cookie and CSRF Token
        - **CSRF where token is duplicated in cookie**
            - Don't need to obtain valid token (perhaps token created in the required format, or even try to use your token and csrfkey cookie)
            - Leverage cookie-setting behavior to place your cookie into victim's browser and feed your token to victim in their CSRF attack.

### 3. **SameSite cookies.**

![[/Untitled 12.png|Untitled 12.png]]

![[/Untitled 1 3.png|Untitled 1 3.png]]

|**Request from**|**Request to**|**Same-site?**|**Same-origin?**|
|---|---|---|---|
|`https://example.com`|`https://example.com`|Yes|Yes|
|`https://app.example.com`|`https://intranet.example.com`|Yes|No: mismatched domain name|
|`https://example.com`|`https://example.com:8080`|Yes|No: mismatched port|
|`https://example.com`|`https://example.co.uk`|No: mismatched eTLD|No: mismatched domain name|
|`https://example.com`|`http://example.com`|No: mismatched scheme|No: mismatched scheme|

  

### Strict (Most secure)

- Browser won't send cookie in any cross-site requests.
- Use when setting cookies for sensitive actions like accessing pages for authenticated users.
- Can impact user experience if cross-site functionality is desired.

  

### Lax

- Sends cookie in cross-site requests if request method is `GET` and the request resulted from a top-level navigation by the user, such as clicking on a link.
- Cookie is not included in cross-site `POST` requests, which are more likely to be targeted for CSRF attacks.

- The cookie is not included in background requests (e.g. initiated by scripts, iframes or image references).

  

![[/Untitled 2 4.png|Untitled 2 4.png]]

### None

- Disables SameSite restrictions for all browsers.
- Cookies will be sent in all requests to the issuing site, even if they were triggered by unrelated third-party sites.
- Most browsers use default cookie behavior if no `SameSite` attribute is given, except Chrome.
- SameSite can be disabled for legitimate tracking cookies.
- Investigate `SameSite=None` or no explicit restrictions on cookies for usefulness.
- Some sites disable SameSite for all cookies, including sensitive ones, to work around Chrome's "Lax-by-default" behavior.
- Here Cookies require `Secure` attribute for HTTPS encryption.
    
    ```
    Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure
    ```
    

---

## Bypassing SameSite Lax restrictions using GET requests

- Servers may not distinguish between GET and POST requests
- If server uses Lax restrictions for session cookies, a CSRF attack can still be performed with a GET request from victim's browser.
- Victim's session cookie will still be included in GET request if top-level navigation is triggered.
- This is one of the simplest ways to carry out the attack.
    
    ```
    <script>
        document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=100000';
    </script>
    ```
    
- Some frameworks allow overriding of the method specified in the request line.
- Symfony supports the _method parameter in forms.
- _method takes precedence over the normal method for routing purposes.
    
    ```
    <form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
        <input type="hidden" name="_method" value="GET">
        <input type="hidden" name="recipient" value="hacker">
        <input type="hidden" name="amount" value="1000000">
    </form>
    ```
    

---

### **SameSite Lax bypass via method override**

- Study the request and notice if that doesn't contain any unpredictable tokens, so may be vulnerable to CSRF.
- Notice at the response if the website doesn't explicitly specify any restrictions when setting session cookies. As a result, the browser will use the default `Lax` restriction level.
- Cause it is `Lax`, we need the request to be `GET` and a top-level navigation by the user.
- If server refused your `GET` request, try overriding the method as shown below:
    
    ```
    GET /my-account/change-email?email=abdelrhmanuzaki%40gmail.com&_method=POST HTTP/1.1
    ```
    
- Example you can use in your PoC:
    
    ```
    <script>
        document.location = "https://website/my-account/change-email?email=abdelrhmanuzaki@gmail.com&_method=POST";
    </script>
    ```
    

---

### **Bypassing SameSite restrictions using on-site gadgets**

  

  

  

  

  

online website to generate a CSRF PoC

[https://csrf.infos3c.net/](https://csrf.infos3c.net/)

---